// SPDX-License-Identifier: Unlicense OR BSD-3-Clause

package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from glyphs_colr_src.go. DO NOT EDIT

func (item *Affine2x3) mustParse(src []byte) {
	_ = src[23] // early bound checking
	item.Xx = Float1616FromUint(binary.BigEndian.Uint32(src[0:]))
	item.Yx = Float1616FromUint(binary.BigEndian.Uint32(src[4:]))
	item.Xy = Float1616FromUint(binary.BigEndian.Uint32(src[8:]))
	item.Yy = Float1616FromUint(binary.BigEndian.Uint32(src[12:]))
	item.Dx = Float1616FromUint(binary.BigEndian.Uint32(src[16:]))
	item.Dy = Float1616FromUint(binary.BigEndian.Uint32(src[20:]))
}

func (item *baseGlyph) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.GlyphID = binary.BigEndian.Uint16(src[0:])
	item.FirstLayerIndex = binary.BigEndian.Uint16(src[2:])
	item.NumLayers = binary.BigEndian.Uint16(src[4:])
}

func (item *ClipBoxFormat1) mustParse(src []byte) {
	_ = src[8] // early bound checking
	item.format = src[0]
	item.XMin = int16(binary.BigEndian.Uint16(src[1:]))
	item.YMin = int16(binary.BigEndian.Uint16(src[3:]))
	item.XMax = int16(binary.BigEndian.Uint16(src[5:]))
	item.YMax = int16(binary.BigEndian.Uint16(src[7:]))
}

func (item *ClipBoxFormat2) mustParse(src []byte) {
	_ = src[12] // early bound checking
	item.format = src[0]
	item.XMin = int16(binary.BigEndian.Uint16(src[1:]))
	item.YMin = int16(binary.BigEndian.Uint16(src[3:]))
	item.XMax = int16(binary.BigEndian.Uint16(src[5:]))
	item.YMax = int16(binary.BigEndian.Uint16(src[7:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[9:])
}

func (item *ColorStop) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.StopOffset = Coord(binary.BigEndian.Uint16(src[0:]))
	item.PaletteIndex = binary.BigEndian.Uint16(src[2:])
	item.Alpha = Coord(binary.BigEndian.Uint16(src[4:]))
}

func (item *Layer) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.GlyphID = binary.BigEndian.Uint16(src[0:])
	item.PaletteIndex = binary.BigEndian.Uint16(src[2:])
}

func (item *PaintColrGlyph) mustParse(src []byte) {
	_ = src[2] // early bound checking
	item.format = src[0]
	item.GlyphID = binary.BigEndian.Uint16(src[1:])
}

func (item *PaintColrLayers) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.format = src[0]
	item.NumLayers = src[1]
	item.FirstLayerIndex = binary.BigEndian.Uint32(src[2:])
}

func (item *PaintSolid) mustParse(src []byte) {
	_ = src[4] // early bound checking
	item.format = src[0]
	item.PaletteIndex = binary.BigEndian.Uint16(src[1:])
	item.Alpha = Coord(binary.BigEndian.Uint16(src[3:]))
}

func (item *PaintVarSolid) mustParse(src []byte) {
	_ = src[8] // early bound checking
	item.format = src[0]
	item.PaletteIndex = binary.BigEndian.Uint16(src[1:])
	item.Alpha = Coord(binary.BigEndian.Uint16(src[3:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[5:])
}

func ParseAffine2x3(src []byte) (Affine2x3, int, error) {
	var item Affine2x3
	n := 0
	if L := len(src); L < 24 {
		return item, 0, fmt.Errorf("reading Affine2x3: "+"EOF: expected length: 24, got %d", L)
	}
	item.mustParse(src)
	n += 24
	return item, n, nil
}

func ParseBaseGlyph(src []byte) (baseGlyph, int, error) {
	var item baseGlyph
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading BaseGlyph: "+"EOF: expected length: 6, got %d", L)
	}
	item.mustParse(src)
	n += 6
	return item, n, nil
}

func ParseBaseGlyphList(src []byte) (baseGlyphList, int, error) {
	var item baseGlyphList
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading BaseGlyphList: "+"EOF: expected length: 4, got %d", L)
	}
	arrayLengthPaintRecords := int(binary.BigEndian.Uint32(src[0:]))
	n += 4

	{

		offset := 4
		for i := 0; i < arrayLengthPaintRecords; i++ {
			elem, read, err := ParseBaseGlyphPaintRecord(src[offset:], src)
			if err != nil {
				return item, 0, fmt.Errorf("reading BaseGlyphList: %s", err)
			}
			item.paintRecords = append(item.paintRecords, elem)
			offset += read
		}
		n = offset
	}
	return item, n, nil
}

func ParseBaseGlyphPaintRecord(src []byte, parentSrc []byte) (baseGlyphPaintRecord, int, error) {
	var item baseGlyphPaintRecord
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading BaseGlyphPaintRecord: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.GlyphID = binary.BigEndian.Uint16(src[0:])
	offsetPaint := int(binary.BigEndian.Uint32(src[2:]))
	n += 6

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(parentSrc); L < offsetPaint {
				return item, 0, fmt.Errorf("reading BaseGlyphPaintRecord: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(parentSrc[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading BaseGlyphPaintRecord: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParseCOLR1(src []byte) (COLR1, int, error) {
	var item COLR1
	n := 0
	{
		var (
			err  error
			read int
		)
		item.colr0, read, err = parseColr0(src[0:])
		if err != nil {
			return item, 0, fmt.Errorf("reading COLR1: %s", err)
		}
		n += read
	}
	if L := len(src); L < n+20 {
		return item, 0, fmt.Errorf("reading COLR1: "+"EOF: expected length: n + 20, got %d", L)
	}
	_ = src[n+19] // early bound checking
	offsetBaseGlyphList := int(binary.BigEndian.Uint32(src[n:]))
	offsetLayerList := int(binary.BigEndian.Uint32(src[n+4:]))
	offsetClipList := int(binary.BigEndian.Uint32(src[n+8:]))
	offsetVarIndexMap := int(binary.BigEndian.Uint32(src[n+12:]))
	offsetItemVariationStore := int(binary.BigEndian.Uint32(src[n+16:]))
	n += 20

	{
		if offsetBaseGlyphList != 0 { // ignore null offset
			if L := len(src); L < offsetBaseGlyphList {
				return item, 0, fmt.Errorf("reading COLR1: "+"EOF: expected length: %d, got %d", offsetBaseGlyphList, L)
			}

			var err error
			item.baseGlyphList, _, err = ParseBaseGlyphList(src[offsetBaseGlyphList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading COLR1: %s", err)
			}

		}
	}
	{
		if offsetLayerList != 0 { // ignore null offset
			if L := len(src); L < offsetLayerList {
				return item, 0, fmt.Errorf("reading COLR1: "+"EOF: expected length: %d, got %d", offsetLayerList, L)
			}

			var err error
			item.LayerList, _, err = ParseLayerList(src[offsetLayerList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading COLR1: %s", err)
			}

		}
	}
	{
		if offsetClipList != 0 { // ignore null offset
			if L := len(src); L < offsetClipList {
				return item, 0, fmt.Errorf("reading COLR1: "+"EOF: expected length: %d, got %d", offsetClipList, L)
			}

			var err error
			item.ClipList, _, err = ParseClipList(src[offsetClipList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading COLR1: %s", err)
			}

		}
	}
	{
		if offsetVarIndexMap != 0 { // ignore null offset
			if L := len(src); L < offsetVarIndexMap {
				return item, 0, fmt.Errorf("reading COLR1: "+"EOF: expected length: %d, got %d", offsetVarIndexMap, L)
			}

			var tmpVarIndexMap DeltaSetMapping
			var err error
			tmpVarIndexMap, _, err = ParseDeltaSetMapping(src[offsetVarIndexMap:])
			if err != nil {
				return item, 0, fmt.Errorf("reading COLR1: %s", err)
			}

			item.VarIndexMap = &tmpVarIndexMap
		}
	}
	{
		if offsetItemVariationStore != 0 { // ignore null offset
			if L := len(src); L < offsetItemVariationStore {
				return item, 0, fmt.Errorf("reading COLR1: "+"EOF: expected length: %d, got %d", offsetItemVariationStore, L)
			}

			var tmpItemVariationStore ItemVarStore
			var err error
			tmpItemVariationStore, _, err = ParseItemVarStore(src[offsetItemVariationStore:])
			if err != nil {
				return item, 0, fmt.Errorf("reading COLR1: %s", err)
			}

			item.ItemVariationStore = &tmpItemVariationStore
		}
	}
	return item, n, nil
}

func ParseClip(src []byte, parentSrc []byte) (Clip, int, error) {
	var item Clip
	n := 0
	if L := len(src); L < 7 {
		return item, 0, fmt.Errorf("reading Clip: "+"EOF: expected length: 7, got %d", L)
	}
	_ = src[6] // early bound checking
	item.StartGlyphID = binary.BigEndian.Uint16(src[0:])
	item.EndGlyphID = binary.BigEndian.Uint16(src[2:])
	offsetClipBox := int(readUint24(src[4:]))
	n += 7

	{
		if offsetClipBox != 0 { // ignore null offset
			if L := len(parentSrc); L < offsetClipBox {
				return item, 0, fmt.Errorf("reading Clip: "+"EOF: expected length: %d, got %d", offsetClipBox, L)
			}

			var (
				err  error
				read int
			)
			item.ClipBox, read, err = ParseClipBox(parentSrc[offsetClipBox:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Clip: %s", err)
			}
			offsetClipBox += read
		}
	}
	return item, n, nil
}

func ParseClipBox(src []byte) (ClipBox, int, error) {
	var item ClipBox

	if L := len(src); L < 1 {
		return item, 0, fmt.Errorf("reading ClipBox: "+"EOF: expected length: 1, got %d", L)
	}
	format := byte(src[0])
	var (
		read int
		err  error
	)
	switch format {
	case 1:
		item, read, err = ParseClipBoxFormat1(src[0:])
	case 2:
		item, read, err = ParseClipBoxFormat2(src[0:])
	default:
		err = fmt.Errorf("unsupported ClipBox format %d", format)
	}
	if err != nil {
		return item, 0, fmt.Errorf("reading ClipBox: %s", err)
	}

	return item, read, nil
}

func ParseClipBoxFormat1(src []byte) (ClipBoxFormat1, int, error) {
	var item ClipBoxFormat1
	n := 0
	if L := len(src); L < 9 {
		return item, 0, fmt.Errorf("reading ClipBoxFormat1: "+"EOF: expected length: 9, got %d", L)
	}
	item.mustParse(src)
	n += 9
	return item, n, nil
}

func ParseClipBoxFormat2(src []byte) (ClipBoxFormat2, int, error) {
	var item ClipBoxFormat2
	n := 0
	if L := len(src); L < 13 {
		return item, 0, fmt.Errorf("reading ClipBoxFormat2: "+"EOF: expected length: 13, got %d", L)
	}
	item.mustParse(src)
	n += 13
	return item, n, nil
}

func ParseClipList(src []byte) (ClipList, int, error) {
	var item ClipList
	n := 0
	if L := len(src); L < 5 {
		return item, 0, fmt.Errorf("reading ClipList: "+"EOF: expected length: 5, got %d", L)
	}
	_ = src[4] // early bound checking
	item.format = src[0]
	arrayLengthClips := int(binary.BigEndian.Uint32(src[1:]))
	n += 5

	{

		offset := 5
		for i := 0; i < arrayLengthClips; i++ {
			elem, read, err := ParseClip(src[offset:], src)
			if err != nil {
				return item, 0, fmt.Errorf("reading ClipList: %s", err)
			}
			item.clips = append(item.clips, elem)
			offset += read
		}
		n = offset
	}
	return item, n, nil
}

func ParseColorLine(src []byte) (ColorLine, int, error) {
	var item ColorLine
	n := 0
	if L := len(src); L < 3 {
		return item, 0, fmt.Errorf("reading ColorLine: "+"EOF: expected length: 3, got %d", L)
	}
	_ = src[2] // early bound checking
	item.Extend = Extend(src[0])
	arrayLengthColorStops := int(binary.BigEndian.Uint16(src[1:]))
	n += 3

	{

		if L := len(src); L < 3+arrayLengthColorStops*6 {
			return item, 0, fmt.Errorf("reading ColorLine: "+"EOF: expected length: %d, got %d", 3+arrayLengthColorStops*6, L)
		}

		item.ColorStops = make([]ColorStop, arrayLengthColorStops) // allocation guarded by the previous check
		for i := range item.ColorStops {
			item.ColorStops[i].mustParse(src[3+i*6:])
		}
		n += arrayLengthColorStops * 6
	}
	return item, n, nil
}

func ParseDeltaSetMapping(src []byte) (DeltaSetMapping, int, error) {
	var item DeltaSetMapping
	n := 0
	if L := len(src); L < 2 {
		return item, 0, fmt.Errorf("reading DeltaSetMapping: "+"EOF: expected length: 2, got %d", L)
	}
	_ = src[1] // early bound checking
	item.format = src[0]
	item.entryFormat = src[1]
	n += 2

	{

		err := item.parseMap(src[2:])
		if err != nil {
			return item, 0, fmt.Errorf("reading DeltaSetMapping: %s", err)
		}
	}
	return item, n, nil
}

func ParseItemVarStore(src []byte) (ItemVarStore, int, error) {
	var item ItemVarStore
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading ItemVarStore: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.format = binary.BigEndian.Uint16(src[0:])
	offsetVariationRegionList := int(binary.BigEndian.Uint32(src[2:]))
	arrayLengthItemVariationDatas := int(binary.BigEndian.Uint16(src[6:]))
	n += 8

	{
		if offsetVariationRegionList != 0 { // ignore null offset
			if L := len(src); L < offsetVariationRegionList {
				return item, 0, fmt.Errorf("reading ItemVarStore: "+"EOF: expected length: %d, got %d", offsetVariationRegionList, L)
			}

			var err error
			item.VariationRegionList, _, err = ParseVariationRegionList(src[offsetVariationRegionList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading ItemVarStore: %s", err)
			}

		}
	}
	{

		if L := len(src); L < 8+arrayLengthItemVariationDatas*4 {
			return item, 0, fmt.Errorf("reading ItemVarStore: "+"EOF: expected length: %d, got %d", 8+arrayLengthItemVariationDatas*4, L)
		}

		item.ItemVariationDatas = make([]ItemVariationData, arrayLengthItemVariationDatas) // allocation guarded by the previous check
		for i := range item.ItemVariationDatas {
			offset := int(binary.BigEndian.Uint32(src[8+i*4:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return item, 0, fmt.Errorf("reading ItemVarStore: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ItemVariationDatas[i], _, err = ParseItemVariationData(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading ItemVarStore: %s", err)
			}
		}
		n += arrayLengthItemVariationDatas * 4
	}
	return item, n, nil
}

func ParseItemVariationData(src []byte) (ItemVariationData, int, error) {
	var item ItemVariationData
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading ItemVariationData: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.itemCount = binary.BigEndian.Uint16(src[0:])
	item.wordDeltaCount = binary.BigEndian.Uint16(src[2:])
	item.regionIndexCount = binary.BigEndian.Uint16(src[4:])
	n += 6

	{
		arrayLength := int(item.regionIndexCount)

		if L := len(src); L < 6+arrayLength*2 {
			return item, 0, fmt.Errorf("reading ItemVariationData: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.RegionIndexes = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.RegionIndexes {
			item.RegionIndexes[i] = binary.BigEndian.Uint16(src[6+i*2:])
		}
		n += arrayLength * 2
	}
	{

		err := item.parseDeltaSets(src[n:])
		if err != nil {
			return item, 0, fmt.Errorf("reading ItemVariationData: %s", err)
		}
	}
	return item, n, nil
}

func ParseLayer(src []byte) (Layer, int, error) {
	var item Layer
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading Layer: "+"EOF: expected length: 4, got %d", L)
	}
	item.mustParse(src)
	n += 4
	return item, n, nil
}

func ParseLayerList(src []byte) (LayerList, int, error) {
	var item LayerList
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading LayerList: "+"EOF: expected length: 4, got %d", L)
	}
	arrayLengthPaintTables := int(binary.BigEndian.Uint32(src[0:]))
	n += 4

	{

		if L := len(src); L < 4+arrayLengthPaintTables*4 {
			return item, 0, fmt.Errorf("reading LayerList: "+"EOF: expected length: %d, got %d", 4+arrayLengthPaintTables*4, L)
		}

		item.paintTables = make([]PaintTable, arrayLengthPaintTables) // allocation guarded by the previous check
		for i := range item.paintTables {
			offset := int(binary.BigEndian.Uint32(src[4+i*4:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return item, 0, fmt.Errorf("reading LayerList: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.paintTables[i], _, err = ParsePaintTable(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading LayerList: %s", err)
			}
		}
		n += arrayLengthPaintTables * 4
	}
	return item, n, nil
}

func ParsePaintColrGlyph(src []byte) (PaintColrGlyph, int, error) {
	var item PaintColrGlyph
	n := 0
	if L := len(src); L < 3 {
		return item, 0, fmt.Errorf("reading PaintColrGlyph: "+"EOF: expected length: 3, got %d", L)
	}
	item.mustParse(src)
	n += 3
	return item, n, nil
}

func ParsePaintColrLayers(src []byte) (PaintColrLayers, int, error) {
	var item PaintColrLayers
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading PaintColrLayers: "+"EOF: expected length: 6, got %d", L)
	}
	item.mustParse(src)
	n += 6
	return item, n, nil
}

func ParsePaintComposite(src []byte) (PaintComposite, int, error) {
	var item PaintComposite
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading PaintComposite: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.format = src[0]
	offsetSourcePaint := int(readUint24(src[1:]))
	item.CompositeMode = CompositeMode(src[4])
	offsetBackdropPaint := int(readUint24(src[5:]))
	n += 8

	{
		if offsetSourcePaint != 0 { // ignore null offset
			if L := len(src); L < offsetSourcePaint {
				return item, 0, fmt.Errorf("reading PaintComposite: "+"EOF: expected length: %d, got %d", offsetSourcePaint, L)
			}

			var (
				err  error
				read int
			)
			item.SourcePaint, read, err = ParsePaintTable(src[offsetSourcePaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintComposite: %s", err)
			}
			offsetSourcePaint += read
		}
	}
	{
		if offsetBackdropPaint != 0 { // ignore null offset
			if L := len(src); L < offsetBackdropPaint {
				return item, 0, fmt.Errorf("reading PaintComposite: "+"EOF: expected length: %d, got %d", offsetBackdropPaint, L)
			}

			var (
				err  error
				read int
			)
			item.BackdropPaint, read, err = ParsePaintTable(src[offsetBackdropPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintComposite: %s", err)
			}
			offsetBackdropPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintGlyph(src []byte) (PaintGlyph, int, error) {
	var item PaintGlyph
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading PaintGlyph: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.GlyphID = binary.BigEndian.Uint16(src[4:])
	n += 6

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintGlyph: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintGlyph: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintLinearGradient(src []byte) (PaintLinearGradient, int, error) {
	var item PaintLinearGradient
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading PaintLinearGradient: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.format = src[0]
	offsetColorLine := int(readUint24(src[1:]))
	item.X0 = int16(binary.BigEndian.Uint16(src[4:]))
	item.Y0 = int16(binary.BigEndian.Uint16(src[6:]))
	item.X1 = int16(binary.BigEndian.Uint16(src[8:]))
	item.Y1 = int16(binary.BigEndian.Uint16(src[10:]))
	item.X2 = int16(binary.BigEndian.Uint16(src[12:]))
	item.Y2 = int16(binary.BigEndian.Uint16(src[14:]))
	n += 16

	{
		if offsetColorLine != 0 { // ignore null offset
			if L := len(src); L < offsetColorLine {
				return item, 0, fmt.Errorf("reading PaintLinearGradient: "+"EOF: expected length: %d, got %d", offsetColorLine, L)
			}

			var err error
			item.ColorLine, _, err = ParseColorLine(src[offsetColorLine:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintLinearGradient: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintRadialGradient(src []byte) (PaintRadialGradient, int, error) {
	var item PaintRadialGradient
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading PaintRadialGradient: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.format = src[0]
	offsetColorLine := int(readUint24(src[1:]))
	item.X0 = int16(binary.BigEndian.Uint16(src[4:]))
	item.Y0 = int16(binary.BigEndian.Uint16(src[6:]))
	item.Radius0 = binary.BigEndian.Uint16(src[8:])
	item.X1 = int16(binary.BigEndian.Uint16(src[10:]))
	item.Y1 = int16(binary.BigEndian.Uint16(src[12:]))
	item.Radius1 = binary.BigEndian.Uint16(src[14:])
	n += 16

	{
		if offsetColorLine != 0 { // ignore null offset
			if L := len(src); L < offsetColorLine {
				return item, 0, fmt.Errorf("reading PaintRadialGradient: "+"EOF: expected length: %d, got %d", offsetColorLine, L)
			}

			var err error
			item.ColorLine, _, err = ParseColorLine(src[offsetColorLine:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintRadialGradient: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintRotate(src []byte) (PaintRotate, int, error) {
	var item PaintRotate
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading PaintRotate: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Angle = Coord(binary.BigEndian.Uint16(src[4:]))
	n += 6

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintRotate: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintRotate: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintRotateAroundCenter(src []byte) (PaintRotateAroundCenter, int, error) {
	var item PaintRotateAroundCenter
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading PaintRotateAroundCenter: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Angle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[6:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[8:]))
	n += 10

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintRotateAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintRotateAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintScale(src []byte) (PaintScale, int, error) {
	var item PaintScale
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading PaintScale: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.ScaleX = Coord(binary.BigEndian.Uint16(src[4:]))
	item.ScaleY = Coord(binary.BigEndian.Uint16(src[6:]))
	n += 8

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintScale: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintScale: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintScaleAroundCenter(src []byte) (PaintScaleAroundCenter, int, error) {
	var item PaintScaleAroundCenter
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading PaintScaleAroundCenter: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.ScaleX = Coord(binary.BigEndian.Uint16(src[4:]))
	item.ScaleY = Coord(binary.BigEndian.Uint16(src[6:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[8:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[10:]))
	n += 12

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintScaleAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintScaleAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintScaleUniform(src []byte) (PaintScaleUniform, int, error) {
	var item PaintScaleUniform
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading PaintScaleUniform: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Scale = Coord(binary.BigEndian.Uint16(src[4:]))
	n += 6

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintScaleUniform: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintScaleUniform: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintScaleUniformAroundCenter(src []byte) (PaintScaleUniformAroundCenter, int, error) {
	var item PaintScaleUniformAroundCenter
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading PaintScaleUniformAroundCenter: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Scale = Coord(binary.BigEndian.Uint16(src[4:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[6:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[8:]))
	n += 10

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintScaleUniformAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintScaleUniformAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintSkew(src []byte) (PaintSkew, int, error) {
	var item PaintSkew
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading PaintSkew: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.XSkewAngle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.YSkewAngle = Coord(binary.BigEndian.Uint16(src[6:]))
	n += 8

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintSkew: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintSkew: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintSkewAroundCenter(src []byte) (PaintSkewAroundCenter, int, error) {
	var item PaintSkewAroundCenter
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading PaintSkewAroundCenter: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.XSkewAngle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.YSkewAngle = Coord(binary.BigEndian.Uint16(src[6:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[8:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[10:]))
	n += 12

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintSkewAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintSkewAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintSolid(src []byte) (PaintSolid, int, error) {
	var item PaintSolid
	n := 0
	if L := len(src); L < 5 {
		return item, 0, fmt.Errorf("reading PaintSolid: "+"EOF: expected length: 5, got %d", L)
	}
	item.mustParse(src)
	n += 5
	return item, n, nil
}

func ParsePaintSweepGradient(src []byte) (PaintSweepGradient, int, error) {
	var item PaintSweepGradient
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading PaintSweepGradient: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.format = src[0]
	offsetColorLine := int(readUint24(src[1:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[4:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[6:]))
	item.StartAngle = Coord(binary.BigEndian.Uint16(src[8:]))
	item.EndAngle = Coord(binary.BigEndian.Uint16(src[10:]))
	n += 12

	{
		if offsetColorLine != 0 { // ignore null offset
			if L := len(src); L < offsetColorLine {
				return item, 0, fmt.Errorf("reading PaintSweepGradient: "+"EOF: expected length: %d, got %d", offsetColorLine, L)
			}

			var err error
			item.ColorLine, _, err = ParseColorLine(src[offsetColorLine:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintSweepGradient: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintTable(src []byte) (PaintTable, int, error) {
	var item PaintTable

	if L := len(src); L < 1 {
		return item, 0, fmt.Errorf("reading PaintTable: "+"EOF: expected length: 1, got %d", L)
	}
	format := byte(src[0])
	var (
		read int
		err  error
	)
	switch format {
	case 11:
		item, read, err = ParsePaintColrGlyph(src[0:])
	case 1:
		item, read, err = ParsePaintColrLayers(src[0:])
	case 32:
		item, read, err = ParsePaintComposite(src[0:])
	case 10:
		item, read, err = ParsePaintGlyph(src[0:])
	case 4:
		item, read, err = ParsePaintLinearGradient(src[0:])
	case 6:
		item, read, err = ParsePaintRadialGradient(src[0:])
	case 24:
		item, read, err = ParsePaintRotate(src[0:])
	case 26:
		item, read, err = ParsePaintRotateAroundCenter(src[0:])
	case 16:
		item, read, err = ParsePaintScale(src[0:])
	case 18:
		item, read, err = ParsePaintScaleAroundCenter(src[0:])
	case 20:
		item, read, err = ParsePaintScaleUniform(src[0:])
	case 22:
		item, read, err = ParsePaintScaleUniformAroundCenter(src[0:])
	case 28:
		item, read, err = ParsePaintSkew(src[0:])
	case 30:
		item, read, err = ParsePaintSkewAroundCenter(src[0:])
	case 2:
		item, read, err = ParsePaintSolid(src[0:])
	case 8:
		item, read, err = ParsePaintSweepGradient(src[0:])
	case 12:
		item, read, err = ParsePaintTransform(src[0:])
	case 14:
		item, read, err = ParsePaintTranslate(src[0:])
	case 5:
		item, read, err = ParsePaintVarLinearGradient(src[0:])
	case 7:
		item, read, err = ParsePaintVarRadialGradient(src[0:])
	case 25:
		item, read, err = ParsePaintVarRotate(src[0:])
	case 27:
		item, read, err = ParsePaintVarRotateAroundCenter(src[0:])
	case 17:
		item, read, err = ParsePaintVarScale(src[0:])
	case 19:
		item, read, err = ParsePaintVarScaleAroundCenter(src[0:])
	case 21:
		item, read, err = ParsePaintVarScaleUniform(src[0:])
	case 23:
		item, read, err = ParsePaintVarScaleUniformAroundCenter(src[0:])
	case 29:
		item, read, err = ParsePaintVarSkew(src[0:])
	case 31:
		item, read, err = ParsePaintVarSkewAroundCenter(src[0:])
	case 3:
		item, read, err = ParsePaintVarSolid(src[0:])
	case 9:
		item, read, err = ParsePaintVarSweepGradient(src[0:])
	case 13:
		item, read, err = ParsePaintVarTransform(src[0:])
	case 15:
		item, read, err = ParsePaintVarTranslate(src[0:])
	default:
		err = fmt.Errorf("unsupported PaintTable format %d", format)
	}
	if err != nil {
		return item, 0, fmt.Errorf("reading PaintTable: %s", err)
	}

	return item, read, nil
}

func ParsePaintTransform(src []byte) (PaintTransform, int, error) {
	var item PaintTransform
	n := 0
	if L := len(src); L < 7 {
		return item, 0, fmt.Errorf("reading PaintTransform: "+"EOF: expected length: 7, got %d", L)
	}
	_ = src[6] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	offsetTransform := int(readUint24(src[4:]))
	n += 7

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintTransform: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintTransform: %s", err)
			}
			offsetPaint += read
		}
	}
	{
		if offsetTransform != 0 { // ignore null offset
			if L := len(src); L < offsetTransform {
				return item, 0, fmt.Errorf("reading PaintTransform: "+"EOF: expected length: %d, got %d", offsetTransform, L)
			}

			var err error
			item.Transform, _, err = ParseAffine2x3(src[offsetTransform:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintTransform: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintTranslate(src []byte) (PaintTranslate, int, error) {
	var item PaintTranslate
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading PaintTranslate: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Dx = int16(binary.BigEndian.Uint16(src[4:]))
	item.Dy = int16(binary.BigEndian.Uint16(src[6:]))
	n += 8

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintTranslate: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintTranslate: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarLinearGradient(src []byte) (PaintVarLinearGradient, int, error) {
	var item PaintVarLinearGradient
	n := 0
	if L := len(src); L < 20 {
		return item, 0, fmt.Errorf("reading PaintVarLinearGradient: "+"EOF: expected length: 20, got %d", L)
	}
	_ = src[19] // early bound checking
	item.format = src[0]
	offsetColorLine := int(readUint24(src[1:]))
	item.X0 = int16(binary.BigEndian.Uint16(src[4:]))
	item.Y0 = int16(binary.BigEndian.Uint16(src[6:]))
	item.X1 = int16(binary.BigEndian.Uint16(src[8:]))
	item.Y1 = int16(binary.BigEndian.Uint16(src[10:]))
	item.X2 = int16(binary.BigEndian.Uint16(src[12:]))
	item.Y2 = int16(binary.BigEndian.Uint16(src[14:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[16:])
	n += 20

	{
		if offsetColorLine != 0 { // ignore null offset
			if L := len(src); L < offsetColorLine {
				return item, 0, fmt.Errorf("reading PaintVarLinearGradient: "+"EOF: expected length: %d, got %d", offsetColorLine, L)
			}

			var err error
			item.ColorLine, _, err = ParseVarColorLine(src[offsetColorLine:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarLinearGradient: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintVarRadialGradient(src []byte) (PaintVarRadialGradient, int, error) {
	var item PaintVarRadialGradient
	n := 0
	if L := len(src); L < 20 {
		return item, 0, fmt.Errorf("reading PaintVarRadialGradient: "+"EOF: expected length: 20, got %d", L)
	}
	_ = src[19] // early bound checking
	item.format = src[0]
	offsetColorLine := int(readUint24(src[1:]))
	item.X0 = int16(binary.BigEndian.Uint16(src[4:]))
	item.Y0 = int16(binary.BigEndian.Uint16(src[6:]))
	item.Radius0 = binary.BigEndian.Uint16(src[8:])
	item.X1 = int16(binary.BigEndian.Uint16(src[10:]))
	item.Y1 = int16(binary.BigEndian.Uint16(src[12:]))
	item.Radius1 = binary.BigEndian.Uint16(src[14:])
	item.VarIndexBase = binary.BigEndian.Uint32(src[16:])
	n += 20

	{
		if offsetColorLine != 0 { // ignore null offset
			if L := len(src); L < offsetColorLine {
				return item, 0, fmt.Errorf("reading PaintVarRadialGradient: "+"EOF: expected length: %d, got %d", offsetColorLine, L)
			}

			var err error
			item.ColorLine, _, err = ParseVarColorLine(src[offsetColorLine:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarRadialGradient: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintVarRotate(src []byte) (PaintVarRotate, int, error) {
	var item PaintVarRotate
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading PaintVarRotate: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Angle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[6:])
	n += 10

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarRotate: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarRotate: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarRotateAroundCenter(src []byte) (PaintVarRotateAroundCenter, int, error) {
	var item PaintVarRotateAroundCenter
	n := 0
	if L := len(src); L < 14 {
		return item, 0, fmt.Errorf("reading PaintVarRotateAroundCenter: "+"EOF: expected length: 14, got %d", L)
	}
	_ = src[13] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Angle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[6:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[8:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[10:])
	n += 14

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarRotateAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarRotateAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarScale(src []byte) (PaintVarScale, int, error) {
	var item PaintVarScale
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading PaintVarScale: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.ScaleX = Coord(binary.BigEndian.Uint16(src[4:]))
	item.ScaleY = Coord(binary.BigEndian.Uint16(src[6:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[8:])
	n += 12

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarScale: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarScale: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarScaleAroundCenter(src []byte) (PaintVarScaleAroundCenter, int, error) {
	var item PaintVarScaleAroundCenter
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading PaintVarScaleAroundCenter: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.ScaleX = Coord(binary.BigEndian.Uint16(src[4:]))
	item.ScaleY = Coord(binary.BigEndian.Uint16(src[6:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[8:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[10:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[12:])
	n += 16

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarScaleAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarScaleAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarScaleUniform(src []byte) (PaintVarScaleUniform, int, error) {
	var item PaintVarScaleUniform
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading PaintVarScaleUniform: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Scale = Coord(binary.BigEndian.Uint16(src[4:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[6:])
	n += 10

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarScaleUniform: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarScaleUniform: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarScaleUniformAroundCenter(src []byte) (PaintVarScaleUniformAroundCenter, int, error) {
	var item PaintVarScaleUniformAroundCenter
	n := 0
	if L := len(src); L < 14 {
		return item, 0, fmt.Errorf("reading PaintVarScaleUniformAroundCenter: "+"EOF: expected length: 14, got %d", L)
	}
	_ = src[13] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Scale = Coord(binary.BigEndian.Uint16(src[4:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[6:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[8:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[10:])
	n += 14

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarScaleUniformAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarScaleUniformAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarSkew(src []byte) (PaintVarSkew, int, error) {
	var item PaintVarSkew
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading PaintVarSkew: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.XSkewAngle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.YSkewAngle = Coord(binary.BigEndian.Uint16(src[6:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[8:])
	n += 12

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarSkew: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarSkew: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarSkewAroundCenter(src []byte) (PaintVarSkewAroundCenter, int, error) {
	var item PaintVarSkewAroundCenter
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading PaintVarSkewAroundCenter: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.XSkewAngle = Coord(binary.BigEndian.Uint16(src[4:]))
	item.YSkewAngle = Coord(binary.BigEndian.Uint16(src[6:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[8:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[10:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[12:])
	n += 16

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarSkewAroundCenter: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarSkewAroundCenter: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParsePaintVarSolid(src []byte) (PaintVarSolid, int, error) {
	var item PaintVarSolid
	n := 0
	if L := len(src); L < 9 {
		return item, 0, fmt.Errorf("reading PaintVarSolid: "+"EOF: expected length: 9, got %d", L)
	}
	item.mustParse(src)
	n += 9
	return item, n, nil
}

func ParsePaintVarSweepGradient(src []byte) (PaintVarSweepGradient, int, error) {
	var item PaintVarSweepGradient
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading PaintVarSweepGradient: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.format = src[0]
	offsetColorLine := int(readUint24(src[1:]))
	item.CenterX = int16(binary.BigEndian.Uint16(src[4:]))
	item.CenterY = int16(binary.BigEndian.Uint16(src[6:]))
	item.StartAngle = Coord(binary.BigEndian.Uint16(src[8:]))
	item.EndAngle = Coord(binary.BigEndian.Uint16(src[10:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[12:])
	n += 16

	{
		if offsetColorLine != 0 { // ignore null offset
			if L := len(src); L < offsetColorLine {
				return item, 0, fmt.Errorf("reading PaintVarSweepGradient: "+"EOF: expected length: %d, got %d", offsetColorLine, L)
			}

			var err error
			item.ColorLine, _, err = ParseVarColorLine(src[offsetColorLine:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarSweepGradient: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintVarTransform(src []byte) (PaintVarTransform, int, error) {
	var item PaintVarTransform
	n := 0
	if L := len(src); L < 7 {
		return item, 0, fmt.Errorf("reading PaintVarTransform: "+"EOF: expected length: 7, got %d", L)
	}
	_ = src[6] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	offsetTransform := int(readUint24(src[4:]))
	n += 7

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarTransform: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarTransform: %s", err)
			}
			offsetPaint += read
		}
	}
	{
		if offsetTransform != 0 { // ignore null offset
			if L := len(src); L < offsetTransform {
				return item, 0, fmt.Errorf("reading PaintVarTransform: "+"EOF: expected length: %d, got %d", offsetTransform, L)
			}

			var err error
			item.Transform, _, err = ParseVarAffine2x3(src[offsetTransform:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarTransform: %s", err)
			}

		}
	}
	return item, n, nil
}

func ParsePaintVarTranslate(src []byte) (PaintVarTranslate, int, error) {
	var item PaintVarTranslate
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading PaintVarTranslate: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.format = src[0]
	offsetPaint := int(readUint24(src[1:]))
	item.Dx = int16(binary.BigEndian.Uint16(src[4:]))
	item.Dy = int16(binary.BigEndian.Uint16(src[6:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[8:])
	n += 12

	{
		if offsetPaint != 0 { // ignore null offset
			if L := len(src); L < offsetPaint {
				return item, 0, fmt.Errorf("reading PaintVarTranslate: "+"EOF: expected length: %d, got %d", offsetPaint, L)
			}

			var (
				err  error
				read int
			)
			item.Paint, read, err = ParsePaintTable(src[offsetPaint:])
			if err != nil {
				return item, 0, fmt.Errorf("reading PaintVarTranslate: %s", err)
			}
			offsetPaint += read
		}
	}
	return item, n, nil
}

func ParseVarAffine2x3(src []byte) (VarAffine2x3, int, error) {
	var item VarAffine2x3
	n := 0
	if L := len(src); L < 28 {
		return item, 0, fmt.Errorf("reading VarAffine2x3: "+"EOF: expected length: 28, got %d", L)
	}
	item.mustParse(src)
	n += 28
	return item, n, nil
}

func ParseVarColorLine(src []byte) (VarColorLine, int, error) {
	var item VarColorLine
	n := 0
	if L := len(src); L < 3 {
		return item, 0, fmt.Errorf("reading VarColorLine: "+"EOF: expected length: 3, got %d", L)
	}
	_ = src[2] // early bound checking
	item.Extend = Extend(src[0])
	arrayLengthColorStops := int(binary.BigEndian.Uint16(src[1:]))
	n += 3

	{

		if L := len(src); L < 3+arrayLengthColorStops*10 {
			return item, 0, fmt.Errorf("reading VarColorLine: "+"EOF: expected length: %d, got %d", 3+arrayLengthColorStops*10, L)
		}

		item.ColorStops = make([]VarColorStop, arrayLengthColorStops) // allocation guarded by the previous check
		for i := range item.ColorStops {
			item.ColorStops[i].mustParse(src[3+i*10:])
		}
		n += arrayLengthColorStops * 10
	}
	return item, n, nil
}

func ParseVariationRegion(src []byte, regionAxesCount int) (VariationRegion, int, error) {
	var item VariationRegion
	n := 0
	{

		if L := len(src); L < regionAxesCount*6 {
			return item, 0, fmt.Errorf("reading VariationRegion: "+"EOF: expected length: %d, got %d", regionAxesCount*6, L)
		}

		item.RegionAxes = make([]RegionAxisCoordinates, regionAxesCount) // allocation guarded by the previous check
		for i := range item.RegionAxes {
			item.RegionAxes[i].mustParse(src[i*6:])
		}
		n += regionAxesCount * 6
	}
	return item, n, nil
}

func ParseVariationRegionList(src []byte) (VariationRegionList, int, error) {
	var item VariationRegionList
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading VariationRegionList: "+"EOF: expected length: 4, got %d", L)
	}
	_ = src[3] // early bound checking
	item.axisCount = binary.BigEndian.Uint16(src[0:])
	arrayLengthVariationRegions := int(binary.BigEndian.Uint16(src[2:]))
	n += 4

	{

		offset := 4
		for i := 0; i < arrayLengthVariationRegions; i++ {
			elem, read, err := ParseVariationRegion(src[offset:], int(item.axisCount))
			if err != nil {
				return item, 0, fmt.Errorf("reading VariationRegionList: %s", err)
			}
			item.VariationRegions = append(item.VariationRegions, elem)
			offset += read
		}
		n = offset
	}
	return item, n, nil
}

func (item *RegionAxisCoordinates) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.StartCoord = Coord(binary.BigEndian.Uint16(src[0:]))
	item.PeakCoord = Coord(binary.BigEndian.Uint16(src[2:]))
	item.EndCoord = Coord(binary.BigEndian.Uint16(src[4:]))
}

func (item *VarAffine2x3) mustParse(src []byte) {
	_ = src[27] // early bound checking
	item.Xx = Float1616FromUint(binary.BigEndian.Uint32(src[0:]))
	item.Yx = Float1616FromUint(binary.BigEndian.Uint32(src[4:]))
	item.Xy = Float1616FromUint(binary.BigEndian.Uint32(src[8:]))
	item.Yy = Float1616FromUint(binary.BigEndian.Uint32(src[12:]))
	item.Dx = Float1616FromUint(binary.BigEndian.Uint32(src[16:]))
	item.Dy = Float1616FromUint(binary.BigEndian.Uint32(src[20:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[24:])
}

func (item *VarColorStop) mustParse(src []byte) {
	_ = src[9] // early bound checking
	item.StopOffset = Coord(binary.BigEndian.Uint16(src[0:]))
	item.PaletteIndex = binary.BigEndian.Uint16(src[2:])
	item.Alpha = Coord(binary.BigEndian.Uint16(src[4:]))
	item.VarIndexBase = binary.BigEndian.Uint32(src[6:])
}

func parseColr0(src []byte) (colr0, int, error) {
	var item colr0
	n := 0
	if L := len(src); L < 14 {
		return item, 0, fmt.Errorf("reading colr0: "+"EOF: expected length: 14, got %d", L)
	}
	_ = src[13] // early bound checking
	item.Version = binary.BigEndian.Uint16(src[0:])
	item.numBaseGlyphRecords = binary.BigEndian.Uint16(src[2:])
	offsetBaseGlyphRecords := int(binary.BigEndian.Uint32(src[4:]))
	offsetLayerRecords := int(binary.BigEndian.Uint32(src[8:]))
	item.numLayerRecords = binary.BigEndian.Uint16(src[12:])
	n += 14

	{
		if offsetBaseGlyphRecords != 0 { // ignore null offset
			if L := len(src); L < offsetBaseGlyphRecords {
				return item, 0, fmt.Errorf("reading colr0: "+"EOF: expected length: %d, got %d", offsetBaseGlyphRecords, L)
			}

			arrayLength := int(item.numBaseGlyphRecords)

			if L := len(src); L < offsetBaseGlyphRecords+arrayLength*6 {
				return item, 0, fmt.Errorf("reading colr0: "+"EOF: expected length: %d, got %d", offsetBaseGlyphRecords+arrayLength*6, L)
			}

			item.baseGlyphRecords = make([]baseGlyph, arrayLength) // allocation guarded by the previous check
			for i := range item.baseGlyphRecords {
				item.baseGlyphRecords[i].mustParse(src[offsetBaseGlyphRecords+i*6:])
			}
			offsetBaseGlyphRecords += arrayLength * 6
		}
	}
	{
		if offsetLayerRecords != 0 { // ignore null offset
			if L := len(src); L < offsetLayerRecords {
				return item, 0, fmt.Errorf("reading colr0: "+"EOF: expected length: %d, got %d", offsetLayerRecords, L)
			}

			arrayLength := int(item.numLayerRecords)

			if L := len(src); L < offsetLayerRecords+arrayLength*4 {
				return item, 0, fmt.Errorf("reading colr0: "+"EOF: expected length: %d, got %d", offsetLayerRecords+arrayLength*4, L)
			}

			item.layerRecords = make([]Layer, arrayLength) // allocation guarded by the previous check
			for i := range item.layerRecords {
				item.layerRecords[i].mustParse(src[offsetLayerRecords+i*4:])
			}
			offsetLayerRecords += arrayLength * 4
		}
	}
	return item, n, nil
}

// Read a set of language orthographies and build Go declarations for
// rune sets which can then be used to identify which languages are
// supported by a given font.
package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"

	"github.com/benoitkugler/textlayout/language"
)

const (
	dirPath    = "generate/orth/"
	outputFile = "lang_table.go"
)

func main() {
	files, err := os.ReadDir(dirPath)
	if err != nil {
		log.Fatal(err)
	}

	// If this fails, referenceLang will need to be 16-bit, instead of a single byte.
	if len(files) > 256 {
		log.Fatalf("%d exceeds implementation limit", len(files))
	}

	out := `
	package fontscan 
	
	// Code generated by generate/main.go DO NOT EDIT.

	// mapping from referenceLang to language and charset
	var referenceLangs = [...]referenceLangEntry{
	`
	for index, file := range files {
		fileName := file.Name()
		runes, err := readOrthFile(fileName)
		if err != nil {
			log.Fatal(fileName, err)
		}

		charsetCode, err := dumpCharset(runes)
		if err != nil {
			log.Fatal(fileName, err)
		}

		langString := strings.Split(fileName, ".")[0]
		lang := language.NewLanguage(langString)

		if len(lang) < 2 {
			log.Fatalf("invalid language name %s", lang)
		}

		out += fmt.Sprintf(`// %d
		{language: %q, charset: %s},
		`, index, lang, charsetCode)
	}
	out += "}"

	err = os.WriteFile(outputFile, []byte(out), os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}

	err = exec.Command("goimports", "-w", outputFile).Run()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(outputFile, "generated.")
}

// By construction, only the 3 last bytes of a rune are taken
// into account meaning that only rune lower than 0x00FFFFFF are valid,
// which is large enough for all valid Unicode points.
const maxCharsetRune = 0xFFFFFF

// convert the rune set to the Go code for fontscan.RuneSet
func dumpCharset(runes map[rune]bool) (string, error) {
	tmp := map[uint16][8]uint32{}

	for r := range runes {
		if r < 0 || r >= maxCharsetRune {
			return "", fmt.Errorf("invalid rune %d", r)
		}

		pageRef := uint16(r >> 8)
		leaf := tmp[pageRef]
		leaf[(r&0xff)>>5] |= (1 << (r & 0x1f))
		tmp[pageRef] = leaf
	}

	var sortedKeys []uint16
	for k := range tmp {
		sortedKeys = append(sortedKeys, k)
	}
	sort.Slice(sortedKeys, func(i, j int) bool { return sortedKeys[i] < sortedKeys[j] })

	out := "RuneSet{\n"
	for _, k := range sortedKeys {
		out += fmt.Sprintf("{ref: 0x%x, set: %#v},\n", k, tmp[k])
	}
	out += "}"
	return out, nil
}

// Build a single charset from a source file
func readOrthFile(fileName string) (map[rune]bool, error) {
	out := map[rune]bool{}

	b, err := os.ReadFile(dirPath + fileName)
	if err != nil {
		return nil, fmt.Errorf("reading %s: %s", fileName, err)
	}

	lines := strings.Split(string(b), "\n")
	for num, line := range lines {
		if strings.HasPrefix(line, "include ") {
			includeFn := strings.TrimSpace(line[8:])
			included, err := readOrthFile(includeFn)
			if err != nil {
				return nil, err
			}
			for k, v := range included {
				out[k] = v
			}
		} else {
			// remove comments and strip whitespaces
			line = strings.TrimSpace(strings.Split(line, "#")[0])
			line = strings.TrimSpace(strings.Split(line, "\t")[0])

			// skip empty lines
			if line == "" {
				continue
			}

			err = parseOrthLine(line, out)
			if err != nil {
				return nil, fmt.Errorf("file %s, line %d: %s", fileName, num+1, err)
			}
		}
	}

	return out, nil
}

// parses one line and add the rune to the charset
// The file format is quite simple, either
// a single hex value or a pair separated with a dash
func parseOrthLine(line string, charset map[rune]bool) error {
	deleteChar := strings.HasPrefix(line, "-")
	if deleteChar {
		line = line[1:]
	}
	var parts []string
	if strings.IndexByte(line, '-') != -1 {
		parts = strings.Split(line, "-")
	} else if strings.Index(line, "..") != -1 {
		parts = strings.Split(line, "..")
	} else {
		parts = []string{line}
	}

	var startString, endString string

	startString, parts = strings.TrimSpace(parts[0]), parts[1:]
	start, err := strconv.ParseInt(strings.TrimPrefix(startString, "0x"), 16, 32)
	if err != nil {
		return err
	}

	end := start
	if len(parts) != 0 {
		endString, parts = strings.TrimSpace(parts[0]), parts[1:]
		end, err = strconv.ParseInt(strings.TrimPrefix(endString, "0x"), 16, 32)
		if err != nil {
			return err
		}
	}

	if len(parts) != 0 {
		return fmt.Errorf("line %s: parse error (too many parts)", line)
	}

	for r := start; r <= end; r++ {
		if deleteChar {
			delete(charset, rune(r))
		} else {
			charset[rune(r)] = true
		}
	}

	return nil
}

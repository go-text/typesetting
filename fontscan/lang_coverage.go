package fontscan

import "github.com/benoitkugler/textlayout/language"

//go:generate go run generate/main.go

// Lang coverage implementation, inspired by the fontconfig FcLangSet type.

type referenceLangEntry struct {
	language language.Language
	charset  RuneSet
}

// referenceLang is an efficiant representation for the
// langs hardcoded in the package
// The mapping from this type to language.Language is generated by TODO:
type referenceLang byte

// referenceLang are stored in `langPageNumber` buckets:
// the index of the bucket is given by the 5 high order bits (l >> 5),
// and the bit index is given by the 3 lower bits (l & 0x1f)
const langPageNumber = 256 / 32

// LangSet holds the set of languages supported by a font.
// These are computed for a font based on orthographic information built into the
// package, supporting all of the ISO 639-1 languages,
// excepted MS, NA, PA, PS, QU, RN, RW, SD, SG, SN, SU and ZA.
type LangSet [langPageNumber]uint32

func NewLangSet(langs ...language.Language) LangSet {
	var l LangSet
	for _, lang := range langs {
		l.Add(lang)
	}
	return l
}

// Langs returns a copy of the langs in the set.
func (ls LangSet) Langs() []language.Language {
	var out []language.Language
	for k, b := range ls {
		for j := 0; j < 32; j++ {
			if b&(1<<j) != 0 {
				index := k<<5 | j
				out = append(out, referenceLangs[index].language)
			}
		}
	}
	return out
}

// TODO:
// func newCharSetFromLang(lang string) *Charset {
// 	country := -1

// 	for i, lcs := range fcLangCharSets {
// 		switch langCompare(lang, lcs.lang) {
// 		case langEqual:
// 			return &lcs.charset
// 		case langDifferentTerritory:
// 			if country == -1 {
// 				country = i
// 			}
// 		}
// 	}
// 	if country == -1 {
// 		return nil
// 	}
// 	return &fcLangCharSets[country].charset
// }

// findExactReferenceLang returns the index in `referenceLangs`
// matching exactly `lang`
// if not found, it returns a negative index p such that
// -p -1 is the index of the first language in `referenceLangs` that comes
// after the 'lang' argument in lexicographic order.
func findExactReferenceLang(lang language.Language) int {
	if len(lang) < 2 { // invalid tag, should not happen in pratice
		return -1
	}

	// speed up string comparison by first checking for the
	// first two bytes
	firstChar, secondChar := lang[0], lang[1]

	low, high, mid, isLess := 0, len(referenceLangs)-1, 0, false
	for low <= high {
		mid = (high + low) >> 1
		refLang := referenceLangs[mid].language
		isLess = refLang[0] < firstChar
		if isLess {
			low = mid + 1
		} else if refLang[0] > firstChar {
			high = mid - 1
		} else {
			// fast path for resolving 2-letter languages, by far the most common
			if refLang[1] == secondChar && len(refLang) == 2 && len(lang) == 2 {
				return mid
			}
			isLess = refLang < lang
			if isLess {
				low = mid + 1
			} else if refLang > lang {
				high = mid - 1
			} else {
				return mid
			}
		}
	}
	if isLess {
		mid++
	}
	return -(mid + 1)
}

func (ls *LangSet) addReferenceLang(ref referenceLang) {
	bucket := ref >> 5
	ls[bucket] |= 1 << (ref & 0x1f)
}

func (ls LangSet) hasReferenceLang(ref referenceLang) bool {
	bucket := ref >> 5
	return ls[bucket]&(1<<(ref&0x1f)) != 0
}

func (ls *LangSet) deleteReferenceLang(ref referenceLang) {
	bucket := ref >> 5
	ls[bucket] &= ^(1 << (ref & 0x1f))
}

// Add adds `lang` to the lang set.
// More precisely, it only adds `lang` if it exactly matches one
// of the language supported by the package.
func (ls *LangSet) Add(lang language.Language) {
	index := findExactReferenceLang(lang)
	if index >= 0 {
		ls.addReferenceLang(referenceLang(index))
	}
}

// Delete removes `lang` from the lang set.
func (ls *LangSet) Delete(lang language.Language) {
	index := findExactReferenceLang(lang)
	if index >= 0 {
		ls.deleteReferenceLang(referenceLang(index))
	}
}

// Contains checks if `lang` is in the set.
// `lang` can either exactly match a language in the set,
// match only regarding primary lang, or not match at all.
func (ls LangSet) Contains(lang language.Language) language.LanguageComparison {
	index := findExactReferenceLang(lang)

	if index >= 0 { // check the inclusion for the reference
		if ls.hasReferenceLang(referenceLang(index)) { // exact match, done
			return language.LanguagesExactMatch
		}
	} else {
		index = -index - 1
	}

	// no exact match, try broader comparison with previous and next entries
	if i := index - 1; i >= 0 {
		r := referenceLangs[i].language.Compare(lang)
		if r != language.LanguagesDiffer && ls.hasReferenceLang(referenceLang(i)) {
			return r
		}
		// else, previous languages won't match
	}
	if i := index; i < len(referenceLangs) {
		r := referenceLangs[i].language.Compare(lang)
		if r != language.LanguagesDiffer && ls.hasReferenceLang(referenceLang(i)) {
			return r
		}
		// else, following languages won't match
	}
	return language.LanguagesDiffer
}

// Keep Han languages separated by eliminating languages that the codePageRange bits says aren't supported
var codePageRange = [...]struct {
	lang string
	bit  byte
}{
	{"ja", 17},
	{"zh-cn", 18},
	{"ko", 19},
	{"zh-tw", 20},
}

// func isExclusiveLang(lang string) bool {
// 	for _, cp := range codePageRange {
// 		if langCompare(lang, cp.lang) == langEqual {
// 			return true
// 		}
// 	}
// 	return false
// }

// func buildLangSet(charset Charset, exclusiveLang string) LangSet {
// 	var exclusiveCharset *Charset
// 	if exclusiveLang != "" {
// 		exclusiveCharset = newCharSetFromLang(exclusiveLang)
// 	}

// 	var ls LangSet

// mainLoop:
// 	for i, langCharset := range fcLangCharSets {
// 		/*
// 		 * Check for Han charsets to make fonts
// 		 * which advertise support for a single language
// 		 * not support other Han languages
// 		 */
// 		if exclusiveCharset != nil && isExclusiveLang(langCharset.lang) {
// 			if len(langCharset.charset.pageNumbers) != len(exclusiveCharset.pageNumbers) {
// 				continue
// 			}

// 			for j, leaf := range langCharset.charset.pages {
// 				if leaf != exclusiveCharset.pages[j] {
// 					continue mainLoop
// 				}
// 			}
// 		}

// 		missing := charsetSubtractCount(langCharset.charset, charset)
// 		if missing == 0 {
// 			ls.addReferenceLang(i)
// 		}
// 	}

// 	return ls
// }

// // Returns a string set of all languages in `ls`.
// func (ls LangSet) getLangs() strSet {
// 	langs := make(strSet)

// 	for i, lg := range fcLangCharSets {
// 		if ls.hasReferenceLang(i) {
// 			langs[lg.lang] = true
// 		}
// 	}

// 	for extra := range ls.extra {
// 		langs[extra] = true
// 	}

// 	return langs
// }
